(function() {
  var OptionParser, argv, child, coffee, compile, file, fs, inspect, options, path, puts, remove_watch_option, spawn, spawn_child, switches, usage, watch, watching, zappa;
  var __indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === item) return i;
    }
    return -1;
  };
  zappa = require('./zappa');
  coffee = require('coffee-script');
  fs = require('fs');
  path = require('path');
  puts = console.log;
  inspect = require('util').inspect;
  spawn = require('child_process').spawn;
  OptionParser = require('coffee-script/lib/optparse').OptionParser;
  child = null;
  file = null;
  watching = [];
  argv = process.argv.slice(2);
  options = null;
  usage = 'Usage:\n  zappa [OPTIONS] path/to/app.coffee';
  switches = [['-h', '--help', 'Displays this wonderful, elucidative help message'], ['-v', '--version', 'Shows zappa version'], ['-p', '--port [NUMBER]', 'The port(s) the app(s) will listen on. Ex.: 8080 or 4567,80,3000'], ['-n', '--hostname [STRING]', 'If omitted, will accept connections to any ipv4 address (INADDR_ANY)'], ['-c', '--compile', 'Compiles the app(s) to a .js file instead of running them.'], ['-w', '--watch', 'Keeps watching the file and restarts the app when it changes.']];
  compile = function(coffee_path, callback) {
    return fs.readFile(coffee_path, function(err, data) {
      var dir, js, js_path;
      if (err) {
        return callback(err);
      } else {
        js = coffee.compile(String(data), {
          bare: true
        });
        js = "require('zappa').run(function(){" + js + "});";
        js_path = path.basename(coffee_path, path.extname(coffee_path)) + '.js';
        dir = path.dirname(coffee_path);
        js_path = path.join(dir, js_path);
        return fs.writeFile(js_path, js, function(err) {
          if (err) {
            return callback(err);
          } else {
            return callback();
          }
        });
      }
    });
  };
  remove_watch_option = function() {
    var i;
    i = argv.indexOf('-w');
    if (i > -1) {
      argv.splice(i, 1);
    }
    i = argv.indexOf('--watch');
    if (i > -1) {
      return argv.splice(i, 1);
    }
  };
  spawn_child = function() {
    child = spawn('zappa', argv);
    child.stdout.on('data', function(data) {
      var included;
      data = String(data);
      if (data.match(/^Included file \".*\.coffee\"/)) {
        included = data.match(/^Included file \"(.*\.coffee)\"/)[1];
        if (__indexOf.call(watching, included) < 0) {
          watch(path.join(path.dirname(file), included));
        }
        watching.push(included);
      }
      return puts(data);
    });
    return child.stderr.on('data', function(data) {
      return puts(String(data));
    });
  };
  watch = function(file) {
    return fs.watchFile(file, {
      persistent: true,
      interval: 500
    }, function(curr, prev) {
      if (curr.size === prev.size && curr.mtime.getTime() === prev.mtime.getTime()) {
        return;
      }
      puts('Changes detected, reloading...');
      child.kill();
      return spawn_child();
    });
  };
  this.run = function() {
    var args, i, p, parser, _ref;
    parser = new OptionParser(switches, usage);
    options = parser.parse(argv);
    args = options.arguments;
    delete options.arguments;
    if (options.port) {
      options.port = options.port.match(/,/) ? options.port.split(',') : [options.port];
      _ref = options.port;
      for (i in _ref) {
        p = _ref[i];
        options.port[i] = parseInt(p);
      }
    }
    if (args.length === 0) {
      if (options.help || argv.length === 0) {
        puts(parser.help());
      }
      if (options.version) {
        puts(zappa.version);
      }
      return process.exit();
    } else {
      file = args[0];
      return path.exists(file, function(exists) {
        if (!exists) {
          puts("\"" + file + "\" not found.");
          process.exit(-1);
        }
        if (options.compile) {
          return compile(file, function(err) {
            if (err) {
              puts(err);
              return process.exit(-1);
            } else {
              return process.exit();
            }
          });
        } else {
          if (options.watch) {
            remove_watch_option();
            spawn_child();
            return watch(file);
          } else {
            return zappa.run_file(file, options);
          }
        }
      });
    }
  };
}).call(this);
